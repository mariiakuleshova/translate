# Сетка поиска и A \* \(A-Star\)

  
Мы собираемся применить то, что мы узнали, к проблеме, связанной с классификацией. Данная проблема – сетка поиска и поиск пути. Мы изучим известный и широко используемый алгоритм A \* \(произносится A-Star\). Это начнется с сетки методов навигации, поиска топологического маршрута, например, поиск маршрута GPS и, наконец, эксперт системы. Вы увидите, что это все версии и вариации на тему деревьев решений, которые мы уже изучили.

  
Некоторые проблемы и наборы данных, особенно в робототехнике, подаются сетке решений для упрощения задачи навигации. Это имеет смысл, если мы пытаемся проложить путь вокруг дома или через поле для робота, мы разделяем землю на сетку типа шахматной доски с координатами, с помощью которых можем отслеживать перемещения нашего робота. Мы могли бы использовать широту и долготу, или мы могли бы выбрать некоторую контрольную точку как ноль - как наша начальная позиция - и отмерить некоторую прямоугольную сетку относительно робота. Сетка служит той же цели, как и в шахматах, ограничивает количество позиций для наблюдения потенциального движения робота и ограничивает пространство передвижения.

Несмотря на то, что этот раздел посвящен поиску по сетке, независимо от того, являются ли карты вовлеченными в процесс или нет, есть парадигмы робота навигации, которые не используют карты, и даже некоторые из них не используют сетки или сетки с неравномерным интервалом. Я разработал систему навигацию для роботов с многослойными картами, где некоторые слои были изменяемыми, а другие нет. Это богатая и плодородная почва для фантазии и экспериментов, и я рекомендую углубиться в эту тему, если вы найдете ее интересной.

Давайте вернемся к теме. У нас есть робот и почти прямоугольная комната, в этом прямоугольнике есть также почти прямоугольные препятствия в форме мебели, стульев, книжных шкафов, камина и т.д. Это простая концепция для того, чтобы выделить сетку - представить это пространство и создать массив чисел для выделения соответствий между физической и виртуальной комнатой. Мы устанавливаем шаг нашей сетки на 1 см - каждый квадрат сетки равен 1 см х 1 см, что дает нам сетку с 580 х 490 квадратов или 284200 квадратов. Мы представляем каждый квадрат в виде целого числа без знака в двумерном массиве в памяти робота.

Теперь нам понадобятся другие данные. У нас есть начальная локация и цель, указанная в виде координат на сетке. Мы поместим координаты 0,0 в ближайшем левом углу комнаты, так чтобы все наши направления и углы были положительными. Я нарисовал карту комнаты для вас ниже, на ней видно, что эта координата всегда будет находить в нижнем левом углу. Обозначаем стандартно по «правилу правой руки», левые повороты - положительные углы, а правые повороты - отрицательные. Х направление горизонтальное, а направление Y вертикальное. Для робота ось X с правой стороны, а ось Y - это направление движения.

Вам может показаться странным, что я подмечаю данные детали, но установка правильной системы координат является первым шагом в сетке поиска и планировании пути. Мы используем декартову систему координат. Мы будем использовать разные правила с широтой и долготой. Здесь мы можем использовать правильно «север-восток вниз» \(север положительный, юг отрицательный, восток положительный, запад отрицательный, ось z направлена ​​вниз, а ось x на роботе совмещена с направлением движения\):

![](../../.gitbook/assets/image%20%2813%29.png)

  
Итак, у нас есть сетка и система координат, с которыми я и вы согласны или, по крайней мере, согласны, что мы оба понимаем, о чем речь. У нас также есть начальное местоположение и конечное местоположение. Наша цель определить оптимальный путь для робота от начала до конца. И между этими положениями мы должны планировать путь вокруг любых препятствий, которые могут быть на пути.

Есть в два основных вида сетки поиска и процедуры поиска пути: тот, когда вы знаете, где абсолютно все расположено на карте – мы будем называть это априорным знанием - и тот, когда вы не знаете, где находятся препятствия - это называется апостериорным знанием. Мы начнем с более легкой позиции, когда мы можем сделать наше планирование пути с совершенным знанием планировки помещения - у нас есть карта.

На самом деле, у нас есть три цели, которые мы пытаемся достичь одновременно с планированием пути. Мы пытаемся достичь нашей цели, избегать препятствий и идти по кратчайшему пути.

Поговорим о том, что мы можем с этим сделать. Мы можем сначала взять карандаш \(наведите на него курсором в начале\) и провести воображаемую линию от нашего старта до цели. Если на нашем пути не было препятствий, мы сделали – и это все. Но подождите, наш карандаш - крошечная линия на бумаге. Наш робот несколько более крупный - и он имеет значительную ширину. Как мы узнаем, что робот проходит в узкий проход? Нам нужно изменить наш карту!

У нас есть сетка или лист бумаги, представляющий сетку. Мы можем нарисовать на этой сетке очертания всех препятствий, в масштабе. У нас есть два стула, столик, камин, ящик для игрушек \(это важно\), два подножия и четыре книжных шкафа. Мы окрашиваем все препятствия в темный цвет. Теперь мы берем более светлый цветной карандаш - скажем, синий цвет - и обводим все пространство вокруг мебели, ширина синего пространства составляет половину ширины робота. Ширина нашего робота 32 см, так что половина составляет 16 см, хорошее четное число. Наша сетка составляет 1 см на квадрат, поэтому мы делаем границу в 16 квадратов вокруг всего. Это выглядит так:

![](../../.gitbook/assets/image%20%2817%29.png)

  
Итак, теперь наша карта имеет два цвета – цвет препятствий и цвет границы «не пускать робота». Если мы зафиксируем центр робота на всей траектории пути за синей границей, то он никуда не врежется. Что касается оценки проходов и дверных проемов, если касательные зоны касаются с обеих сторон, так что в середине не осталось белых квадратов, робот слишком велик, чтобы здесь пройти. Вы можете видеть это вокруг пуфика в верхнем левом углу иллюстрации.

Посмотрим на нашу линию сейчас. Нам нужен способ написать компьютерный алгоритм, который определяет белые квадраты, через которые может пройти робот и которые доставят нас от начальной точки к финишу точка.

Поскольку у нас есть цель в декартовых координатах, и у нас есть стартовая точка, мы можем выразить расстояние по прямой от начала до конца. Если начальная точка x1, y1, а конечная точка равна x2, y2, тогда расстояние равно квадратному корню из суммы квадратов разности между точками:

$$
distance = sqrt(x2-x1)^2 + (y2-y1)^2)
$$

  
Одним из подходов является использование метода волнового фронта. Мы знаем, где начало. Мы выходим в каждом направлении, то есть на восемь квадратов, примыкающих к начальной точке. Если в каком-то из направлений мы ударились о препятствие или зашли в запретную зону, мы отбрасываем его как невозможный путь. Мы отслеживаем, как мы дошли до каждого квадрата, которые на моей иллюстрации обозначены стрелками. Мы используем информацию о том, как мы пришли на квадрат, потому что мы еще не знаем, куда мы идем дальше. Сейчас же мы берем все новые квадраты и делаем то же самое снова - берём один квадрат, видим какой из его восьми соседей является реальным ходом, а затем оставляем стрелку \(или указатель на расположение предыдущего квадрата\) на нем, чтобы отслеживать, как мы туда попали. Мы продолжаем делать это пока мы не доберемся до нашей цели. Мы ведем учет порядка рассмотренных нами квадратов и следуем за стрелками назад к нашей отправной точке.

Если более одного квадрата ведут нас к текущему квадрату, то мы выбираем кратчайший путь.

![](../../.gitbook/assets/image%20%287%29.png)

  
В этом примере вы могли заметить, что я позволил роботу совершать диагональные переходы, из одного квадрата в другой. Я мог бы также указать, что разрешены только прямые повороты, но это не очень эффективно и сложно для системы привода робота, если мы позволим переходы только по прямому угол. Такие повороты конечно несколько упрощают обработку, так как вам нужно будет рассмотреть только четырех соседей вокруг квадрата вместо восьми.

Другой подход, который выглядит многообещающим, называется Greedy Best First. Вместо того, чтобы вести учет и проверять все точки сетки, как мы делали в методе волнового фронта, мы просто учитываем единственный квадрат наилучшего пути из восьми, которые мы только что протестировали. Мера, которую мы используем, чтобы решить, какой квадрат сохранить, тот, который ближе всего к нашей цели по прямому пути. Мы удаляем квадраты, которые заблокированы препятствиями, конечно. В результате мы рассматриваем намного \(действительно намного!\) меньше квадратов, чем в методе волнового фронта планирования пути:

![](../../.gitbook/assets/image%20%2812%29.png)

  
Подходит ли такая техника для всех случаев? На самом деле, нет.

Почему нет? Она кажется простым алгоритмом, и мы рассматривали только успешные действия. Проблема в том, что он не может справиться с локальными минимумами. Что это еще за локальные минимумы? Это место на карте, где роботу придется идти назад, чтобы найти хороший путь. Самый простой тип минимумов для визуализации - это U-образная область, куда робот может войти, но из которой не может выйти обратно. Также алгоритм Greedy Best First не пытается найти кратчайший путь, он просто находит путь. Если мы хотим найти кратчайший путь, нам нужно применить еще немного знаний из математики:

![](../../.gitbook/assets/image%20%2815%29.png)



